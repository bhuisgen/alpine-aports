From b649a6da8f0fe30297687e819fa201a1601a094f Mon Sep 17 00:00:00 2001
From: Boris HUISGEN <bhuisgen@hbis.fr>
Date: Sat, 15 Oct 2016 18:58:23 +0200
Subject: [PATCH] Add rootfs option with custom path support

Signed-off-by: Boris HUISGEN <boris@foobot.io>
---
 conf/zabbix_agentd.conf                     |  10 ++
 include/common.h                            |  31 ++--
 include/zbxtypes.h                          |   6 -
 src/libs/zbxcommon/file.c                   | 269 +++++++++++++++++++++++-----
 src/libs/zbxcommon/misc.c                   |  28 ---
 src/libs/zbxconf/cfg.c                      |  60 ++++++-
 src/libs/zbxdb/db.c                         |  30 +++-
 src/libs/zbxicmpping/icmpping.c             |   4 +-
 src/libs/zbxlog/log.c                       |  38 +++-
 src/libs/zbxnix/fatal.c                     |   2 +-
 src/libs/zbxnix/pid.c                       |  30 +++-
 src/libs/zbxsysinfo/common/file.c           |  11 +-
 src/libs/zbxsysinfo/hpux/net.c              |   6 +-
 src/libs/zbxsysinfo/linux/boottime.c        |   2 +-
 src/libs/zbxsysinfo/linux/cpu.c             |   4 +-
 src/libs/zbxsysinfo/linux/diskio.c          |   4 +-
 src/libs/zbxsysinfo/linux/diskspace.c       |   2 +-
 src/libs/zbxsysinfo/linux/hardware.c        |  14 +-
 src/libs/zbxsysinfo/linux/kernel.c          |   2 +-
 src/libs/zbxsysinfo/linux/memory.c          |   4 +-
 src/libs/zbxsysinfo/linux/net.c             |  14 +-
 src/libs/zbxsysinfo/linux/proc.c            |  41 +++--
 src/libs/zbxsysinfo/linux/sensors.c         |  34 ++--
 src/libs/zbxsysinfo/linux/software.c        |   8 +-
 src/libs/zbxsysinfo/linux/swap.c            |  17 +-
 src/libs/zbxsysinfo/osf/proc.c              |  20 +--
 src/libs/zbxsysinfo/solaris/diskspace.c     |   2 +-
 src/libs/zbxsysinfo/solaris/proc.c          |  67 ++++---
 src/zabbix_agent/cpustat.c                  |   2 +-
 src/zabbix_agent/logfiles.c                 |  14 +-
 src/zabbix_agent/stats.c                    |   5 +-
 src/zabbix_agent/zabbix_agentd.c            |   2 +
 src/zabbix_agent/zbxconf.c                  |   1 +
 src/zabbix_agent/zbxconf.h                  |   3 +
 src/zabbix_server/snmptrapper/snmptrapper.c |  62 ++++++-
 35 files changed, 617 insertions(+), 232 deletions(-)

diff --git a/conf/zabbix_agentd.conf b/conf/zabbix_agentd.conf
index 3a6fe59..579c644 100644
--- a/conf/zabbix_agentd.conf
+++ b/conf/zabbix_agentd.conf
@@ -250,6 +250,16 @@ Hostname=Zabbix server
 # Default:
 # User=zabbix
 
+### Option: RootFilesystem
+#	Use a custom rootfs path to access host system metrics and agent checks based on files.
+#	Only needed when the agent is running inside a container/jail environment.
+#	/ 		- default rootfs path
+#	/rootfs - access to /proc/mounts will be translated to /rootfs/proc/mounts
+#
+# Mandatory: no
+# Default:
+# RootFilesystem=/
+
 ### Option: Include
 #	You may include individual files or all files in a directory in the configuration file.
 #	Installing Zabbix will create include directory in /usr/local/etc, unless modified during the compile time.
diff --git a/include/common.h b/include/common.h
index 0f38422..713b5c3 100644
--- a/include/common.h
+++ b/include/common.h
@@ -70,6 +70,10 @@
 #define ON	1
 #define OFF	0
 
+#ifndef _WINDOWS
+extern char *CONFIG_ROOT_FILESYSTEM;
+#endif
+
 #if defined(_WINDOWS)
 #	define	ZBX_SERVICE_NAME_LEN	64
 extern char ZABBIX_SERVICE_NAME[ZBX_SERVICE_NAME_LEN];
@@ -762,18 +766,6 @@ do				\
 }				\
 while (0)
 
-#define zbx_fclose(file)	\
-				\
-do				\
-{				\
-	if (file)		\
-	{			\
-		fclose(file);	\
-		file = NULL;	\
-	}			\
-}				\
-while (0)
-
 #define THIS_SHOULD_NEVER_HAPPEN	zbx_error("ERROR [file:%s,line:%d] "				\
 							"Something impossible has just happened.",	\
 							__FILE__, __LINE__)
@@ -1133,14 +1125,23 @@ zbx_uint64_t	suffix2factor(char c);
 
 #if defined(_WINDOWS)
 typedef struct __stat64	zbx_stat_t;
-int	__zbx_stat(const char *path, zbx_stat_t *buf);
-int	__zbx_open(const char *pathname, int flags);
 #else
 typedef struct stat	zbx_stat_t;
 #endif	/* _WINDOWS */
 
-void	find_cr_lf_szbyte(const char *encoding, const char **cr, const char **lf, size_t *szbyte);
+int	zbx_stat(const char *path, zbx_stat_t *buf);
+int	zbx_open(const char *pathname, int flags);
+int	zbx_close(int fd);
 int	zbx_read(int fd, char *buf, size_t count, const char *encoding);
+#ifndef _WINDOWS
+ssize_t	zbx_readlink(const char *pathname, char *buf, size_t bufsiz);
+DIR*	zbx_opendir(const char *name);
+int	zbx_closedir(DIR *dirp);
+struct dirent *zbx_readdir(DIR *dirp);
+#endif
+FILE* 	zbx_fopen(const char *pathname, const char *mode);
+int	zbx_fclose(FILE *file);
+void	find_cr_lf_szbyte(const char *encoding, const char **cr, const char **lf, size_t *szbyte);
 int	zbx_is_regular_file(const char *path);
 
 int	MAIN_ZABBIX_ENTRY(int flags);
diff --git a/include/zbxtypes.h b/include/zbxtypes.h
index 38cc3df..4f55e62 100644
--- a/include/zbxtypes.h
+++ b/include/zbxtypes.h
@@ -34,9 +34,6 @@
 #if defined(_WINDOWS)
 #	include <strsafe.h>
 
-#	define zbx_stat(path, buf)		__zbx_stat(path, buf)
-#	define zbx_open(pathname, flags)	__zbx_open(pathname, flags | O_BINARY)
-
 #	ifndef __UINT64_C
 #		define __UINT64_C(x)	x
 #	endif
@@ -76,9 +73,6 @@ typedef __int64	zbx_offset_t;
 
 #else	/* _WINDOWS */
 
-#	define zbx_stat(path, buf)		stat(path, buf)
-#	define zbx_open(pathname, flags)	open(pathname, flags)
-
 #	ifndef __UINT64_C
 #		ifdef UINT64_C
 #			define __UINT64_C(c)	(UINT64_C(c))
diff --git a/src/libs/zbxcommon/file.c b/src/libs/zbxcommon/file.c
index a7ed80c..ce09c84 100644
--- a/src/libs/zbxcommon/file.c
+++ b/src/libs/zbxcommon/file.c
@@ -18,61 +18,122 @@
 **/
 
 #include "common.h"
+#include "log.h"
 
-#if defined(_WINDOWS)
-int	__zbx_open(const char *pathname, int flags)
+#ifndef _WINDOWS
+char	*CONFIG_ROOT_FILESYSTEM;
+
+/******************************************************************************
+ *                                                                            *
+ * Function: __zbx_zbx_rootfs_path                                            *
+ *                                                                            *
+ * Purpose: convert a path to rootfs path                                     *
+ *                                                                            *
+ * Parameters: dst - destination buffer pointer                               *
+ *             count - size of destination buffer                             *
+ *             src - source buffer pointer                                    *
+ *                                                                            *
+ * Author: Boris HUISGEN                                                      *
+ *                                                                            *
+ ******************************************************************************/
+
+void	__zbx_zbx_rootfs_path(char *dst, size_t count, const char *src)
+{
+	if ((CONFIG_ROOT_FILESYSTEM == NULL) || (strcmp(CONFIG_ROOT_FILESYSTEM, "/") == 0))
+	{
+		zbx_snprintf(dst, count, "%s", src);
+	}
+	else
+	{
+		zbx_snprintf(dst, count, "%s%s", CONFIG_ROOT_FILESYSTEM, src);
+	}
+
+	zabbix_log(LOG_LEVEL_DEBUG, "Rootfs path conversion: \"%s\" -> \"%s\"", src, dst);
+}
+
+#endif
+
+int	zbx_stat(const char *path, zbx_stat_t *buf)
+{
+#ifdef _WINDOWS
+	int	ret, fd;
+	wchar_t	*wpath;
+
+	wpath = zbx_utf8_to_unicode(path);
+
+	if (-1 == (ret = _wstat64(wpath, buf)))
+		goto out;
+
+	if (0 != S_ISDIR(buf->st_mode) || 0 != buf->st_size)
+		goto out;
+
+	/* In the case of symlinks _wstat64 returns zero file size.   */
+	/* Try to work around it by opening the file and using fstat. */
+
+	ret = -1;
+
+	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+	{
+		ret = _fstat64(fd, buf);
+		_close(fd);
+	}
+out:
+	zbx_free(wpath);
+
+	return ret;
+#else
+	char 	rootpath[MAX_STRING_LEN];
+	int	ret;
+
+	__zbx_zbx_rootfs_path(rootpath, sizeof(rootpath), path);
+
+	ret = stat(rootpath, buf);
+
+	return ret;
+#endif
+}
+
+int	zbx_open(const char *pathname, int flags)
 {
+#ifdef _WINDOWS
 	int	ret;
 	wchar_t	*wpathname;
 
 	wpathname = zbx_utf8_to_unicode(pathname);
-	ret = _wopen(wpathname, flags);
+	ret = _wopen(wpathname, flags | O_BINARY);
 	zbx_free(wpathname);
 
 	return ret;
-}
+#else
+	char 	rootpath[MAX_STRING_LEN];
+	int	ret;
+
+	__zbx_zbx_rootfs_path(rootpath, sizeof(rootpath), pathname);
+
+	ret = open(rootpath, flags);
+
+	return ret;
 #endif
+}
 
-void	find_cr_lf_szbyte(const char *encoding, const char **cr, const char **lf, size_t *szbyte)
+int	zbx_close(int fd)
 {
-	/* default is single-byte character set */
-	*cr = "\r";
-	*lf = "\n";
-	*szbyte = 1;
+#ifdef _WINDOWS
+	int ret;
 
-	if ('\0' != *encoding)
-	{
-		if (0 == strcasecmp(encoding, "UNICODE") || 0 == strcasecmp(encoding, "UNICODELITTLE") ||
-				0 == strcasecmp(encoding, "UTF-16") || 0 == strcasecmp(encoding, "UTF-16LE") ||
-				0 == strcasecmp(encoding, "UTF16") || 0 == strcasecmp(encoding, "UTF16LE"))
-		{
-			*cr = "\r\0";
-			*lf = "\n\0";
-			*szbyte = 2;
-		}
-		else if (0 == strcasecmp(encoding, "UNICODEBIG") || 0 == strcasecmp(encoding, "UNICODEFFFE") ||
-				0 == strcasecmp(encoding, "UTF-16BE") || 0 == strcasecmp(encoding, "UTF16BE"))
-		{
-			*cr = "\0\r";
-			*lf = "\0\n";
-			*szbyte = 2;
-		}
-		else if (0 == strcasecmp(encoding, "UTF-32") || 0 == strcasecmp(encoding, "UTF-32LE") ||
-				0 == strcasecmp(encoding, "UTF32") || 0 == strcasecmp(encoding, "UTF32LE"))
-		{
-			*cr = "\r\0\0\0";
-			*lf = "\n\0\0\0";
-			*szbyte = 4;
-		}
-		else if (0 == strcasecmp(encoding, "UTF-32BE") || 0 == strcasecmp(encoding, "UTF32BE"))
-		{
-			*cr = "\0\0\0\r";
-			*lf = "\0\0\0\n";
-			*szbyte = 4;
-		}
-	}
+	ret = _close(fd);
+
+	return ret;
+#else
+	int ret;
+
+	ret = close(fd);
+
+	return ret;
+#endif
 }
 
+
 /******************************************************************************
  *                                                                            *
  * Function: zbx_read                                                         *
@@ -144,6 +205,133 @@ int	zbx_read(int fd, char *buf, size_t count, const char *encoding)
 	return (int)i;
 }
 
+#ifndef _WINDOWS
+
+ssize_t zbx_readlink(const char *pathname, char *buf, size_t bufsiz)
+{
+	char 	rootpath[MAX_STRING_LEN];
+	ssize_t bytes;
+
+	__zbx_zbx_rootfs_path(rootpath, sizeof(rootpath), pathname);
+
+	bytes = readlink(rootpath, buf, bufsiz);
+
+	return bytes;
+}
+
+DIR*	zbx_opendir(const char *name)
+{
+	char 	rootpath[MAX_STRING_LEN];
+	DIR*	dir;
+
+	__zbx_zbx_rootfs_path(rootpath, sizeof(rootpath), name);
+
+	dir = opendir(rootpath);
+
+	return dir;
+}
+
+int	zbx_closedir(DIR *dirp)
+{
+	int ret;
+
+	ret = closedir(dirp);
+
+	return ret;
+}
+
+
+struct dirent*	zbx_readdir(DIR *dirp)
+{
+	struct dirent	*d_ent;
+
+	d_ent = readdir(dirp);
+
+	return d_ent;
+}
+
+#endif
+
+FILE*	zbx_fopen(const char *pathname, const char *mode)
+{
+#ifdef _WINDOWS
+	FILE*	fd;
+	wchar_t	*pathname;
+	wchar_t	*wmode;
+
+	wpathname = zbx_utf8_to_unicode(path);
+	wmode = zbx_utf8_to_unicode(mode);
+	fd = _wfopen(wpathname, wmode);
+
+	zbx_free(wpathname);
+	zbx_free(wmode);
+
+	return fd;
+#else
+	char 	rootpath[MAX_STRING_LEN];
+	FILE*	fd;
+
+	__zbx_zbx_rootfs_path(rootpath, sizeof(rootpath), pathname);
+
+	fd = fopen(rootpath, mode);
+
+	return fd;
+#endif
+}
+
+int	zbx_fclose(FILE *file)
+{
+	int ret=0;
+
+	if (file)
+	{
+	    ret = fclose(file);
+	    file = NULL;
+	}
+
+	return ret;
+}
+
+void	find_cr_lf_szbyte(const char *encoding, const char **cr, const char **lf, size_t *szbyte)
+{
+	/* default is single-byte character set */
+	*cr = "\r";
+	*lf = "\n";
+	*szbyte = 1;
+
+	if ('\0' != *encoding)
+	{
+		if (0 == strcasecmp(encoding, "UNICODE") || 0 == strcasecmp(encoding, "UNICODELITTLE") ||
+				0 == strcasecmp(encoding, "UTF-16") || 0 == strcasecmp(encoding, "UTF-16LE") ||
+				0 == strcasecmp(encoding, "UTF16") || 0 == strcasecmp(encoding, "UTF16LE"))
+		{
+			*cr = "\r\0";
+			*lf = "\n\0";
+			*szbyte = 2;
+		}
+		else if (0 == strcasecmp(encoding, "UNICODEBIG") || 0 == strcasecmp(encoding, "UNICODEFFFE") ||
+				0 == strcasecmp(encoding, "UTF-16BE") || 0 == strcasecmp(encoding, "UTF16BE"))
+		{
+			*cr = "\0\r";
+			*lf = "\0\n";
+			*szbyte = 2;
+		}
+		else if (0 == strcasecmp(encoding, "UTF-32") || 0 == strcasecmp(encoding, "UTF-32LE") ||
+				0 == strcasecmp(encoding, "UTF32") || 0 == strcasecmp(encoding, "UTF32LE"))
+		{
+			*cr = "\r\0\0\0";
+			*lf = "\n\0\0\0";
+			*szbyte = 4;
+		}
+		else if (0 == strcasecmp(encoding, "UTF-32BE") || 0 == strcasecmp(encoding, "UTF32BE"))
+		{
+			*cr = "\0\0\0\r";
+			*lf = "\0\0\0\n";
+			*szbyte = 4;
+		}
+	}
+}
+
 int	zbx_is_regular_file(const char *path)
 {
 	zbx_stat_t	st;
@@ -153,3 +341,4 @@ int	zbx_is_regular_file(const char *path)
 
 	return FAIL;
 }
+
diff --git a/src/libs/zbxcommon/misc.c b/src/libs/zbxcommon/misc.c
index edd464c..882d0bc 100644
--- a/src/libs/zbxcommon/misc.c
+++ b/src/libs/zbxcommon/misc.c
@@ -59,34 +59,6 @@ ZBX_THREAD_LOCAL volatile sig_atomic_t	zbx_timed_out;	/* 0 - no timeout occurred
 char	ZABBIX_SERVICE_NAME[ZBX_SERVICE_NAME_LEN] = APPLICATION_NAME;
 char	ZABBIX_EVENT_SOURCE[ZBX_SERVICE_NAME_LEN] = APPLICATION_NAME;
 
-int	__zbx_stat(const char *path, zbx_stat_t *buf)
-{
-	int	ret, fd;
-	wchar_t	*wpath;
-
-	wpath = zbx_utf8_to_unicode(path);
-
-	if (-1 == (ret = _wstat64(wpath, buf)))
-		goto out;
-
-	if (0 != S_ISDIR(buf->st_mode) || 0 != buf->st_size)
-		goto out;
-
-	/* In the case of symlinks _wstat64 returns zero file size.   */
-	/* Try to work around it by opening the file and using fstat. */
-
-	ret = -1;
-
-	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
-	{
-		ret = _fstat64(fd, buf);
-		_close(fd);
-	}
-out:
-	zbx_free(wpath);
-
-	return ret;
-}
 
 #endif
 
diff --git a/src/libs/zbxconf/cfg.c b/src/libs/zbxconf/cfg.c
index d2e8cc0..09bf4ef 100644
--- a/src/libs/zbxconf/cfg.c
+++ b/src/libs/zbxconf/cfg.c
@@ -276,7 +276,35 @@ static int	parse_cfg_dir(const char *path, const char *pattern, struct cfg_line
 	{
 		file = zbx_dsprintf(file, "%s/%s", path, d->d_name);
 
-		if (0 != zbx_stat(file, &sb) || 0 == S_ISREG(sb.st_mode))
+#ifdef _WINDOWS
+		int	stat, fd;
+		wchar_t	*wpath;
+
+		wpath = zbx_utf8_to_unicode(file);
+
+		if (-1 == (stat = _wstat64(wpath, &sb)))
+			goto out;
+
+		if (0 != S_ISDIR(sb->st_mode) || 0 != sb->st_size)
+			goto out;
+
+		/* In the case of symlinks _wstat64 returns zero file size.   */
+		/* Try to work around it by opening the file and using fstat. */
+
+		stat = -1;
+
+		if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+		{
+			stat = _fstat64(fd, &sb);
+			_close(fd);
+		}
+out:
+		zbx_free(wpath);
+
+		if (0 != stat)
+#else
+		if (0 != stat(file, &sb) || 0 == S_ISREG(sb.st_mode))
+#endif
 			continue;
 
 		if (NULL != pattern && SUCCEED != match_glob(d->d_name, pattern))
@@ -324,7 +352,35 @@ static int	parse_cfg_object(const char *cfg_file, struct cfg_line *cfg, int leve
 	if (SUCCEED != parse_glob(cfg_file, &path, &pattern))
 		goto clean;
 
-	if (0 != zbx_stat(path, &sb))
+#ifdef _WINDOWS
+	int	stat, fd;
+	wchar_t	*wpath;
+
+	wpath = zbx_utf8_to_unicode(path);
+
+	if (-1 == (stat = _wstat64(wpath, &sb)))
+		goto out;
+
+	if (0 != S_ISDIR(sb->st_mode) || 0 != sb->st_size)
+		goto out;
+
+	/* In the case of symlinks _wstat64 returns zero file size.   */
+	/* Try to work around it by opening the file and using fstat. */
+
+	stat = -1;
+
+	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+	{
+		stat = _fstat64(fd, &sb);
+		_close(fd);
+	}
+out:
+	zbx_free(wpath);
+
+	if (0 != stat)
+#else
+	if (0 != stat(path, &sb))
+#endif
 	{
 		zbx_error("%s: %s", path, zbx_strerror(errno));
 		goto clean;
diff --git a/src/libs/zbxdb/db.c b/src/libs/zbxdb/db.c
index 0f5fee8..4566fe7 100644
--- a/src/libs/zbxdb/db.c
+++ b/src/libs/zbxdb/db.c
@@ -650,7 +650,35 @@ void	zbx_db_init(const char *dbname, const char *const db_schema)
 #if defined(HAVE_SQLITE3)
 	zbx_stat_t	buf;
 
-	if (0 != zbx_stat(dbname, &buf))
+#ifdef _WINDOWS
+	int	stat, fd;
+	wchar_t	*wpath;
+
+	wpath = zbx_utf8_to_unicode(dbname);
+
+	if (-1 == (stat = _wstat64(wpath, &buf)))
+		goto out;
+
+	if (0 != S_ISDIR(buf->st_mode) || 0 != buf->st_size)
+		goto out;
+
+	/* In the case of symlinks _wstat64 returns zero file size.   */
+	/* Try to work around it by opening the file and using fstat. */
+
+	stat = -1;
+
+	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+	{
+		stat = _fstat64(fd, &buf);
+		_close(fd);
+	}
+out:
+	zbx_free(wpath);
+
+	if (0 != stat)
+#else
+	if (0 != stat(dbname, &buf))
+#endif
 	{
 		zabbix_log(LOG_LEVEL_WARNING, "cannot open database file \"%s\": %s", dbname, zbx_strerror(errno));
 		zabbix_log(LOG_LEVEL_WARNING, "creating database ...");
diff --git a/src/libs/zbxicmpping/icmpping.c b/src/libs/zbxicmpping/icmpping.c
index 3e1fd85..0a118a5 100644
--- a/src/libs/zbxicmpping/icmpping.c
+++ b/src/libs/zbxicmpping/icmpping.c
@@ -226,7 +226,7 @@ static int	process_ping(ZBX_FPING_HOST *hosts, int hosts_count, int count, int i
 	zbx_snprintf(tmp, sizeof(tmp), "%s %s 2>&1 <%s", CONFIG_FPING_LOCATION, params, filename);
 #endif	/* HAVE_IPV6 */
 
-	if (NULL == (f = fopen(filename, "w")))
+	if (NULL == (f = zbx_fopen(filename, "w")))
 	{
 		zbx_snprintf(error, max_error_len, "%s: %s", filename, zbx_strerror(errno));
 		return ret;
@@ -240,7 +240,7 @@ static int	process_ping(ZBX_FPING_HOST *hosts, int hosts_count, int count, int i
 		fprintf(f, "%s\n", hosts[i].addr);
 	}
 
-	fclose(f);
+	zbx_fclose(f);
 
 	zabbix_log(LOG_LEVEL_DEBUG, "%s", tmp);
 
diff --git a/src/libs/zbxlog/log.c b/src/libs/zbxlog/log.c
index 44b2fed..80925a9 100644
--- a/src/libs/zbxlog/log.c
+++ b/src/libs/zbxlog/log.c
@@ -152,8 +152,36 @@ static void	rotate_log(const char *filename)
 		return;
 	}
 
-	if (0 != zbx_stat(filename, &buf))
-		return;
+#ifdef _WINDOWS
+	int	stat, fd;
+	wchar_t	*wpath;
+
+	wpath = zbx_utf8_to_unicode(filename);
+
+	if (-1 == (stat = _wstat64(wpath, &buf)))
+		goto out;
+
+	if (0 != S_ISDIR(buf->st_mode) || 0 != buf->st_size)
+		goto out;
+
+	/* In the case of symlinks _wstat64 returns zero file size.   */
+	/* Try to work around it by opening the file and using fstat. */
+
+	stat = -1;
+
+	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+	{
+		stat = _fstat64(fd, &buf);
+		_close(fd);
+	}
+out:
+	zbx_free(wpath);
+
+	if (0 != stat)
+#else
+	if (0 != stat(filename, &buf))
+#endif
+	    return;
 
 	new_size = buf.st_size;
 
@@ -205,7 +233,7 @@ static void	rotate_log(const char *filename)
 						filename,
 						filename_old);
 
-				zbx_fclose(log_file);
+				fclose(log_file);
 
 				new_size = 0;
 			}
@@ -309,7 +337,7 @@ int	zabbix_open_log(int type, int level, const char *filename)
 		}
 
 		strscpy(log_filename, filename);
-		zbx_fclose(log_file);
+		fclose(log_file);
 	}
 	else if (LOG_TYPE_CONSOLE == type)
 	{
@@ -449,7 +477,7 @@ void	__zbx_zabbix_log(int level, const char *fmt, ...)
 
 			fprintf(log_file, "\n");
 
-			zbx_fclose(log_file);
+			fclose(log_file);
 		}
 
 		unlock_log();
diff --git a/src/libs/zbxnix/fatal.c b/src/libs/zbxnix/fatal.c
index f245d2f..00c3b77 100644
--- a/src/libs/zbxnix/fatal.c
+++ b/src/libs/zbxnix/fatal.c
@@ -315,7 +315,7 @@ void	print_fatal_info(void *context)
 
 	zabbix_log(LOG_LEVEL_CRIT, "=== Memory map: ===");
 
-	if (NULL != (fd = fopen("/proc/self/maps", "r")))
+	if (NULL != (fd = zbx_fopen("/proc/self/maps", "r")))
 	{
 		char line[1024];
 
diff --git a/src/libs/zbxnix/pid.c b/src/libs/zbxnix/pid.c
index e135372..94272ce 100644
--- a/src/libs/zbxnix/pid.c
+++ b/src/libs/zbxnix/pid.c
@@ -37,7 +37,35 @@ int	create_pid_file(const char *pidfile)
 	fl.l_pid = getpid();
 
 	/* check if pid file already exists */
-	if (0 == zbx_stat(pidfile, &buf))
+#ifdef _WINDOWS
+	int	stat, fd;
+	wchar_t	*wpath;
+
+	wpath = zbx_utf8_to_unicode(pidfile);
+
+	if (-1 == (stat = _wstat64(wpath, &buf)))
+		goto out;
+
+	if (0 != S_ISDIR(buf->st_mode) || 0 != buf->st_size)
+		goto out;
+
+	/* In the case of symlinks _wstat64 returns zero file size.   */
+	/* Try to work around it by opening the file and using fstat. */
+
+	stat = -1;
+
+	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+	{
+		stat = _fstat64(fd, &buf);
+		_close(fd);
+	}
+out:
+	zbx_free(wpath);
+
+	if (0 == stat)
+#else
+	if (0 == stat(pidfile, &buf))
+#endif
 	{
 		if (-1 == (fd = open(pidfile, O_WRONLY | O_APPEND)))
 		{
diff --git a/src/libs/zbxsysinfo/common/file.c b/src/libs/zbxsysinfo/common/file.c
index 9421437..0b79a14 100644
--- a/src/libs/zbxsysinfo/common/file.c
+++ b/src/libs/zbxsysinfo/common/file.c
@@ -49,6 +49,7 @@ int	VFS_FILE_SIZE(AGENT_REQUEST *request, AGENT_RESULT *result)
 	}
 
 	if (0 != zbx_stat(filename, &buf))
+
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot obtain file information: %s", zbx_strerror(errno)));
 		goto err;
@@ -248,7 +249,7 @@ int	VFS_FILE_CONTENTS(AGENT_REQUEST *request, AGENT_RESULT *result)
 	ret = SYSINFO_RET_OK;
 err:
 	if (-1 != f)
-		close(f);
+		zbx_close(f);
 
 	return ret;
 }
@@ -369,7 +370,7 @@ int	VFS_FILE_REGEXP(AGENT_REQUEST *request, AGENT_RESULT *result)
 	ret = SYSINFO_RET_OK;
 err:
 	if (-1 != f)
-		close(f);
+		zbx_close(f);
 
 	return ret;
 }
@@ -481,7 +482,7 @@ int	VFS_FILE_REGMATCH(AGENT_REQUEST *request, AGENT_RESULT *result)
 	ret = SYSINFO_RET_OK;
 err:
 	if (-1 != f)
-		close(f);
+		zbx_close(f);
 
 	return ret;
 }
@@ -561,7 +562,7 @@ int	VFS_FILE_MD5SUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	ret = SYSINFO_RET_OK;
 err:
 	if (-1 != f)
-		close(f);
+		zbx_close(f);
 
 	return ret;
 }
@@ -697,7 +698,7 @@ int	VFS_FILE_CKSUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	ret = SYSINFO_RET_OK;
 err:
 	if (-1 != f)
-		close(f);
+		zbx_close(f);
 
 	return ret;
 }
diff --git a/src/libs/zbxsysinfo/hpux/net.c b/src/libs/zbxsysinfo/hpux/net.c
index 367fbf4..315ef15 100644
--- a/src/libs/zbxsysinfo/hpux/net.c
+++ b/src/libs/zbxsysinfo/hpux/net.c
@@ -386,12 +386,12 @@ static int	get_net_stat(Ext_mib_t *mib, const char *if_name)
 {
 	int	fd, ppa;
 
-	if (-1 == (fd = open("/dev/dlpi", O_RDWR)))
+	if (-1 == (fd = zbx_open("/dev/dlpi", O_RDWR)))
 		return FAIL;
 
 	if (FAIL == get_ppa(fd, if_name, &ppa))
 	{
-		close(fd);
+		zbx_close(fd);
 		return FAIL;
 	}
 
@@ -403,7 +403,7 @@ static int	get_net_stat(Ext_mib_t *mib, const char *if_name)
 
 	dlpi_detach(fd);
 
-	close(fd);
+	zbx_close(fd);
 
 	return SUCCEED;
 }
diff --git a/src/libs/zbxsysinfo/linux/boottime.c b/src/libs/zbxsysinfo/linux/boottime.c
index 9452bc7..a3f2b1e 100644
--- a/src/libs/zbxsysinfo/linux/boottime.c
+++ b/src/libs/zbxsysinfo/linux/boottime.c
@@ -30,7 +30,7 @@ int	SYSTEM_BOOTTIME(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 	ZBX_UNUSED(request);
 
-	if (NULL == (f = fopen("/proc/stat", "r")))
+	if (NULL == (f = zbx_fopen("/proc/stat", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/stat: %s", zbx_strerror(errno)));
 		return ret;
diff --git a/src/libs/zbxsysinfo/linux/cpu.c b/src/libs/zbxsysinfo/linux/cpu.c
index 497cb65..1805e2a 100644
--- a/src/libs/zbxsysinfo/linux/cpu.c
+++ b/src/libs/zbxsysinfo/linux/cpu.c
@@ -196,7 +196,7 @@ int     SYSTEM_CPU_SWITCHES(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 	ZBX_UNUSED(request);
 
-	if (NULL == (f = fopen("/proc/stat", "r")))
+	if (NULL == (f = zbx_fopen("/proc/stat", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/stat: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
@@ -231,7 +231,7 @@ int     SYSTEM_CPU_INTR(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 	ZBX_UNUSED(request);
 
-	if (NULL == (f = fopen("/proc/stat", "r")))
+	if (NULL == (f = zbx_fopen("/proc/stat", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/stat: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
diff --git a/src/libs/zbxsysinfo/linux/diskio.c b/src/libs/zbxsysinfo/linux/diskio.c
index b9ff5f2..a088233 100644
--- a/src/libs/zbxsysinfo/linux/diskio.c
+++ b/src/libs/zbxsysinfo/linux/diskio.c
@@ -91,7 +91,7 @@ int	get_diskstat(const char *devname, zbx_uint64_t *dstat)
 			dev_exists = SUCCEED;
 	}
 
-	if (NULL == (f = fopen(INFO_FILE_NAME, "r")))
+	if (NULL == (f = zbx_fopen(INFO_FILE_NAME, "r")))
 		return FAIL;
 
 	while (NULL != fgets(tmp, sizeof(tmp), f))
@@ -150,7 +150,7 @@ static int	get_kernel_devname(const char *devname, char *kernel_devname, size_t
 		strscpy(dev_path, ZBX_DEV_PFX);
 	strscat(dev_path, devname);
 
-	if (zbx_stat(dev_path, &dev_st) < 0 || NULL == (f = fopen(INFO_FILE_NAME, "r")))
+	if (zbx_stat(dev_path, &dev_st) < 0 || NULL == (f = zbx_fopen(INFO_FILE_NAME, "r")))
 		return ret;
 
 	while (NULL != fgets(tmp, sizeof(tmp), f))
diff --git a/src/libs/zbxsysinfo/linux/diskspace.c b/src/libs/zbxsysinfo/linux/diskspace.c
index e49b803..089f950 100644
--- a/src/libs/zbxsysinfo/linux/diskspace.c
+++ b/src/libs/zbxsysinfo/linux/diskspace.c
@@ -127,7 +127,7 @@ int	VFS_FS_DISCOVERY(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 	ZBX_UNUSED(request);
 
-	if (NULL == (f = fopen("/proc/mounts", "r")))
+	if (NULL == (f = zbx_fopen("/proc/mounts", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/mounts: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
diff --git a/src/libs/zbxsysinfo/linux/hardware.c b/src/libs/zbxsysinfo/linux/hardware.c
index 20df220..8f510b6 100644
--- a/src/libs/zbxsysinfo/linux/hardware.c
+++ b/src/libs/zbxsysinfo/linux/hardware.c
@@ -104,7 +104,7 @@ static int	get_dmi_info(char *buf, int bufsize, int flags)
 	static int	smbios_status = SMBIOS_STATUS_UNKNOWN;
 	static size_t	smbios_len, smbios;	/* length and address of SMBIOS table (if found) */
 
-	if (-1 == (fd = open(DEV_MEM, O_RDONLY)))
+	if (-1 == (fd = zbx_open(DEV_MEM, O_RDONLY)))
 		return ret;
 
 	if (SMBIOS_STATUS_UNKNOWN == smbios_status)	/* look for SMBIOS table only once */
@@ -193,7 +193,7 @@ static int	get_dmi_info(char *buf, int bufsize, int flags)
 clean:
 	zbx_free(smbuf);
 close:
-	close(fd);
+	zbx_close(fd);
 
 	return ret;
 }
@@ -246,14 +246,14 @@ static zbx_uint64_t	get_cpu_max_freq(int cpu_num)
 
 	zbx_snprintf(filename, sizeof(filename), CPU_MAX_FREQ_FILE, cpu_num);
 
-	f = fopen(filename, "r");
+	f = zbx_fopen(filename, "r");
 
 	if (NULL != f)
 	{
 		if (1 != fscanf(f, ZBX_FS_UI64, &freq))
 			freq = FAIL;
 
-		fclose(f);
+		zbx_fclose(f);
 	}
 
 	return freq;
@@ -330,7 +330,7 @@ int     SYSTEM_HW_CPU(AGENT_REQUEST *request, AGENT_RESULT *result)
 		return SYSINFO_RET_FAIL;
 	}
 
-	if (NULL == (f = fopen(HW_CPU_INFO_FILE, "r")))
+	if (NULL == (f = zbx_fopen(HW_CPU_INFO_FILE, "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open " HW_CPU_INFO_FILE ": %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
@@ -462,7 +462,7 @@ int     SYSTEM_HW_MACADDR(AGENT_REQUEST *request, AGENT_RESULT *result)
 	ifc.ifc_buf = buffer;
 	if (-1 == ioctl(s, SIOCGIFCONF, &ifc))
 	{
-		close(s);
+		zbx_close(s);
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot set socket parameters: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
@@ -524,7 +524,7 @@ int     SYSTEM_HW_MACADDR(AGENT_REQUEST *request, AGENT_RESULT *result)
 	SET_STR_RESULT(result, zbx_strdup(NULL, buffer));
 
 	zbx_vector_str_destroy(&addresses);
-	close(s);
+	zbx_close(s);
 
 	return SYSINFO_RET_OK;
 }
diff --git a/src/libs/zbxsysinfo/linux/kernel.c b/src/libs/zbxsysinfo/linux/kernel.c
index 11b8f8b..7773e48 100644
--- a/src/libs/zbxsysinfo/linux/kernel.c
+++ b/src/libs/zbxsysinfo/linux/kernel.c
@@ -26,7 +26,7 @@ static int	read_uint64_from_procfs(const char *path, zbx_uint64_t *value)
 	char	line[MAX_STRING_LEN];
 	FILE	*f;
 
-	if (NULL != (f = fopen(path, "r")))
+	if (NULL != (f = zbx_fopen(path, "r")))
 	{
 		if (NULL != fgets(line, sizeof(line), f))
 		{
diff --git a/src/libs/zbxsysinfo/linux/memory.c b/src/libs/zbxsysinfo/linux/memory.c
index 50589d4..7a90b60 100644
--- a/src/libs/zbxsysinfo/linux/memory.c
+++ b/src/libs/zbxsysinfo/linux/memory.c
@@ -73,7 +73,7 @@ static int	VM_MEMORY_CACHED(AGENT_RESULT *result)
 	zbx_uint64_t	value;
 	int		res;
 
-	if (NULL == (f = fopen("/proc/meminfo", "r")))
+	if (NULL == (f = zbx_fopen("/proc/meminfo", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/meminfo: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
@@ -140,7 +140,7 @@ static int	VM_MEMORY_AVAILABLE(AGENT_RESULT *result)
 
 	/* try MemAvailable (present since Linux 3.14), falling back to a calculation based on sysinfo() and Cached */
 
-	if (NULL == (f = fopen("/proc/meminfo", "r")))
+	if (NULL == (f = zbx_fopen("/proc/meminfo", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/meminfo: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
diff --git a/src/libs/zbxsysinfo/linux/net.c b/src/libs/zbxsysinfo/linux/net.c
index 53b49a7..724e523 100644
--- a/src/libs/zbxsysinfo/linux/net.c
+++ b/src/libs/zbxsysinfo/linux/net.c
@@ -211,7 +211,7 @@ static int	get_net_stat(const char *if_name, net_stat_t *result, char **error)
 		return SYSINFO_RET_FAIL;
 	}
 
-	if (NULL == (f = fopen("/proc/net/dev", "r")))
+	if (NULL == (f = zbx_fopen("/proc/net/dev", "r")))
 	{
 		*error = zbx_dsprintf(NULL, "Cannot open /proc/net/dev: %s", zbx_strerror(errno));
 		return SYSINFO_RET_FAIL;
@@ -277,9 +277,9 @@ static int	get_net_stat(const char *if_name, net_stat_t *result, char **error)
 static int    proc_read_tcp_listen(const char *filename, char **buffer, int *buffer_alloc)
 {
 	int     n, fd, ret = -1, offset = 0;
-	char    *start, *end;
+	char	*start, *end;
 
-	if (-1 == (fd = open(filename, O_RDONLY)))
+	if (-1 == (fd = zbx_open(filename, O_RDONLY)))
 		return -1;
 
 	while (0 != (n = read(fd, *buffer + offset, *buffer_alloc - offset)))
@@ -338,7 +338,7 @@ static int    proc_read_tcp_listen(const char *filename, char **buffer, int *buf
 
 	ret = offset;
 out:
-	close(fd);
+	zbx_close(fd);
 
 	return ret;
 }
@@ -362,7 +362,7 @@ static int	proc_read_file(const char *filename, char **buffer, int *buffer_alloc
 {
 	int	n, fd, ret = -1, offset = 0;
 
-	if (-1 == (fd = open(filename, O_RDONLY)))
+	if (-1 == (fd = zbx_open(filename, O_RDONLY)))
 		return -1;
 
 	while (0 != (n = read(fd, *buffer + offset, *buffer_alloc - offset)))
@@ -381,7 +381,7 @@ static int	proc_read_file(const char *filename, char **buffer, int *buffer_alloc
 
 	ret = offset;
 out:
-	close(fd);
+	zbx_close(fd);
 
 	return ret;
 }
@@ -529,7 +529,7 @@ int	NET_IF_DISCOVERY(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 	ZBX_UNUSED(request);
 
-	if (NULL == (f = fopen("/proc/net/dev", "r")))
+	if (NULL == (f = zbx_fopen("/proc/net/dev", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc/net/dev: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
diff --git a/src/libs/zbxsysinfo/linux/proc.c b/src/libs/zbxsysinfo/linux/proc.c
index 090fcc6..be350f3 100644
--- a/src/libs/zbxsysinfo/linux/proc.c
+++ b/src/libs/zbxsysinfo/linux/proc.c
@@ -323,7 +323,7 @@ static int	get_total_memory(zbx_uint64_t *total_memory)
 	FILE	*f;
 	int	ret = FAIL;
 
-	if (NULL != (f = fopen("/proc/meminfo", "r")))
+	if (NULL != (f = zbx_fopen("/proc/meminfo", "r")))
 	{
 		ret = byte_value_from_proc_file(f, "MemTotal:", NULL, total_memory);
 		zbx_fclose(f);
@@ -506,13 +506,13 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 		}
 	}
 
-	if (NULL == (dir = opendir("/proc")))
+	if (NULL == (dir = zbx_opendir("/proc")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		zbx_fclose(f_cmd);
 		zbx_fclose(f_stat);
@@ -522,12 +522,12 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/cmdline", entries->d_name);
 
-		if (NULL == (f_cmd = fopen(tmp, "r")))
+		if (NULL == (f_cmd = zbx_fopen(tmp, "r")))
 			continue;
 
 		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/status", entries->d_name);
 
-		if (NULL == (f_stat = fopen(tmp, "r")))
+		if (NULL == (f_stat = zbx_fopen(tmp, "r")))
 			continue;
 
 		if (FAIL == check_procname(f_cmd, f_stat, procname))
@@ -665,7 +665,7 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 clean:
 	zbx_fclose(f_cmd);
 	zbx_fclose(f_stat);
-	closedir(dir);
+	zbx_closedir(dir);
 
 	if ((0 == proccount && 0 != mem_type_tried) || 0 != invalid_read)
 	{
@@ -769,13 +769,13 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	if (1 == invalid_user)	/* handle 0 for non-existent user after all parameters have been parsed and validated */
 		goto out;
 
-	if (NULL == (dir = opendir("/proc")))
+	if (NULL == (dir = zbx_opendir("/proc")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		zbx_fclose(f_cmd);
 		zbx_fclose(f_stat);
@@ -785,12 +785,12 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/cmdline", entries->d_name);
 
-		if (NULL == (f_cmd = fopen(tmp, "r")))
+		if (NULL == (f_cmd = zbx_fopen(tmp, "r")))
 			continue;
 
 		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/status", entries->d_name);
 
-		if (NULL == (f_stat = fopen(tmp, "r")))
+		if (NULL == (f_stat = zbx_fopen(tmp, "r")))
 			continue;
 
 		if (FAIL == check_procname(f_cmd, f_stat, procname))
@@ -809,7 +809,7 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	}
 	zbx_fclose(f_cmd);
 	zbx_fclose(f_stat);
-	closedir(dir);
+	zbx_closedir(dir);
 out:
 	SET_UI64_RESULT(result, proccount);
 
@@ -839,11 +839,11 @@ static int	proc_get_process_name(pid_t pid, char **procname)
 
 	zbx_snprintf(tmp, sizeof(tmp), "/proc/%d/stat", (int)pid);
 
-	if (-1 == (fd = open(tmp, O_RDONLY)))
+	if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 		return FAIL;
 
 	n = read(fd, tmp, sizeof(tmp));
-	close(fd);
+	zbx_close(fd);
 
 	if (-1 == n)
 		return FAIL;
@@ -887,7 +887,7 @@ static int	proc_get_process_cmdline(pid_t pid, char **cmdline, size_t *cmdline_n
 	*cmdline_nbytes = 0;
 	zbx_snprintf(tmp, sizeof(tmp), "/proc/%d/cmdline", (int)pid);
 
-	if (-1 == (fd = open(tmp, O_RDONLY)))
+	if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 		return FAIL;
 
 	*cmdline = zbx_malloc(NULL, cmdline_alloc);
@@ -903,7 +903,7 @@ static int	proc_get_process_cmdline(pid_t pid, char **cmdline, size_t *cmdline_n
 		}
 	}
 
-	close(fd);
+	zbx_close(fd);
 
 	if (0 < *cmdline_nbytes)
 	{
@@ -1005,7 +1005,7 @@ static int	proc_read_cpu_util(zbx_procstat_util_t *procutil)
 
 	zbx_snprintf(tmp, sizeof(tmp), "/proc/%d/stat", (int)procutil->pid);
 
-	if (-1 == (fd = open(tmp, O_RDONLY)))
+	if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 		return -errno;
 
 	if (-1 == (n = read(fd, tmp, sizeof(tmp) - 1)))
@@ -1063,7 +1063,7 @@ static int	proc_read_cpu_util(zbx_procstat_util_t *procutil)
 
 	ret = -ENODATA;
 out:
-	close(fd);
+	zbx_close(fd);
 
 	return ret;
 }
@@ -1239,7 +1239,6 @@ out:
 int	zbx_proc_get_processes(zbx_vector_ptr_t *processes, unsigned int flags)
 {
 	const char		*__function_name = "zbx_proc_get_processes";
-
 	DIR			*dir;
 	struct dirent		*entries;
 	int			ret = FAIL, pid;
@@ -1247,10 +1246,10 @@ int	zbx_proc_get_processes(zbx_vector_ptr_t *processes, unsigned int flags)
 
 	zabbix_log(LOG_LEVEL_TRACE, "In %s()", __function_name);
 
-	if (NULL == (dir = opendir("/proc")))
+	if (NULL == (dir = zbx_opendir("/proc")))
 		goto out;
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		/* skip entries not containing pids */
 		if (FAIL == is_uint32(entries->d_name, &pid))
@@ -1262,7 +1261,7 @@ int	zbx_proc_get_processes(zbx_vector_ptr_t *processes, unsigned int flags)
 		zbx_vector_ptr_append(processes, proc);
 	}
 
-	closedir(dir);
+	zbx_closedir(dir);
 
 	ret = SUCCEED;
 out:
diff --git a/src/libs/zbxsysinfo/linux/sensors.c b/src/libs/zbxsysinfo/linux/sensors.c
index c19f153..018fd30 100644
--- a/src/libs/zbxsysinfo/linux/sensors.c
+++ b/src/libs/zbxsysinfo/linux/sensors.c
@@ -35,7 +35,7 @@ static void	count_sensor(int do_task, const char *filename, double *aggr, int *c
 	char	line[MAX_STRING_LEN];
 	double	value;
 
-	if (NULL == (f = fopen(filename, "r")))
+	if (NULL == (f = zbx_fopen(filename, "r")))
 		return;
 
 	if (NULL == fgets(line, sizeof(line), f))
@@ -99,7 +99,7 @@ static const char	*sysfs_read_attr(const char *device, char **attribute)
 	{
 		zbx_snprintf(path, MAX_STRING_LEN, "%s%s/name", device, *location);
 
-		if (NULL != (f = fopen(path, "r")))
+		if (NULL != (f = zbx_fopen(path, "r")))
 		{
 			p = fgets(buf, ATTR_MAX, f);
 			zbx_fclose(f);
@@ -146,13 +146,13 @@ static int	get_device_info(const char *dev_path, const char *dev_name, char *dev
 	/* Find bus type */
 	zbx_snprintf(linkpath, MAX_STRING_LEN, "%s/device/subsystem", dev_path);
 
-	sub_len = readlink(linkpath, subsys_path, MAX_STRING_LEN - 1);
+	sub_len = zbx_readlink(linkpath, subsys_path, MAX_STRING_LEN - 1);
 
 	if (0 > sub_len && ENOENT == errno)
 	{
 		/* Fallback to "bus" link for kernels <= 2.6.17 */
 		zbx_snprintf(linkpath, MAX_STRING_LEN, "%s/device/bus", dev_path);
-		sub_len = readlink(linkpath, subsys_path, MAX_STRING_LEN - 1);
+		sub_len = zbx_readlink(linkpath, subsys_path, MAX_STRING_LEN - 1);
 	}
 
 	if (0 > sub_len)
@@ -270,10 +270,10 @@ static void	get_device_sensors(int do_task, const char *device, const char *name
 		struct dirent	*deviceent, *sensorent;
 		char		devicename[MAX_STRING_LEN];
 
-		if (NULL == (devicedir = opendir(DEVICE_DIR)))
+		if (NULL == (devicedir = zbx_opendir(DEVICE_DIR)))
 			return;
 
-		while (NULL != (deviceent = readdir(devicedir)))
+		while (NULL != (deviceent = zbx_readdir(devicedir)))
 		{
 			if (0 == strcmp(deviceent->d_name, ".") || 0 == strcmp(deviceent->d_name, ".."))
 				continue;
@@ -283,10 +283,10 @@ static void	get_device_sensors(int do_task, const char *device, const char *name
 
 			zbx_snprintf(devicename, sizeof(devicename), "%s/%s", DEVICE_DIR, deviceent->d_name);
 
-			if (NULL == (sensordir = opendir(devicename)))
+			if (NULL == (sensordir = zbx_opendir(devicename)))
 				continue;
 
-			while (NULL != (sensorent = readdir(sensordir)))
+			while (NULL != (sensorent = zbx_readdir(sensordir)))
 			{
 				if (0 == strcmp(sensorent->d_name, ".") || 0 == strcmp(sensorent->d_name, ".."))
 					continue;
@@ -297,9 +297,9 @@ static void	get_device_sensors(int do_task, const char *device, const char *name
 				zbx_snprintf(sensorname, sizeof(sensorname), "%s/%s", devicename, sensorent->d_name);
 				count_sensor(do_task, sensorname, aggr, cnt);
 			}
-			closedir(sensordir);
+			zbx_closedir(sensordir);
 		}
-		closedir(devicedir);
+		zbx_closedir(devicedir);
 	}
 #else
 	DIR		*sensordir = NULL, *devicedir = NULL;
@@ -311,16 +311,16 @@ static void	get_device_sensors(int do_task, const char *device, const char *name
 
 	zbx_snprintf(hwmon_dir, sizeof(hwmon_dir), "%s", DEVICE_DIR);
 
-	if (NULL == (devicedir = opendir(hwmon_dir)))
+	if (NULL == (devicedir = zbx_opendir(hwmon_dir)))
 		return;
 
-	while (NULL != (deviceent = readdir(devicedir)))
+	while (NULL != (deviceent = zbx_readdir(devicedir)))
 	{
 		if (0 == strcmp(deviceent->d_name, ".") || 0 == strcmp(deviceent->d_name, ".."))
 			continue;
 
 		zbx_snprintf(devicepath, sizeof(devicepath), "%s/%s/device", DEVICE_DIR, deviceent->d_name);
-		dev_len = readlink(devicepath, deviced, MAX_STRING_LEN - 1);
+		dev_len = zbx_readlink(devicepath, deviced, MAX_STRING_LEN - 1);
 		zbx_snprintf(devicepath, sizeof(devicepath), "%s/%s", DEVICE_DIR, deviceent->d_name);
 
 		if (0 > dev_len)
@@ -356,10 +356,10 @@ static void	get_device_sensors(int do_task, const char *device, const char *name
 			{
 				zbx_snprintf(regex, sizeof(regex), "%s[0-9]*_input", name);
 
-				if (NULL == (sensordir = opendir(devicepath)))
+				if (NULL == (sensordir = zbx_opendir(devicepath)))
 					goto out;
 
-				while (NULL != (sensorent = readdir(sensordir)))
+				while (NULL != (sensorent = zbx_readdir(sensordir)))
 				{
 					if (0 == strcmp(sensorent->d_name, ".") ||
 							0 == strcmp(sensorent->d_name, ".."))
@@ -372,12 +372,12 @@ static void	get_device_sensors(int do_task, const char *device, const char *name
 							sensorent->d_name);
 					count_sensor(do_task, sensorname, aggr, cnt);
 				}
-				closedir(sensordir);
+				zbx_closedir(sensordir);
 			}
 		}
 	}
 out:
-	closedir(devicedir);
+	zbx_closedir(devicedir);
 #endif
 }
 
diff --git a/src/libs/zbxsysinfo/linux/software.c b/src/libs/zbxsysinfo/linux/software.c
index e0c0efc..61ec05f 100644
--- a/src/libs/zbxsysinfo/linux/software.c
+++ b/src/libs/zbxsysinfo/linux/software.c
@@ -62,7 +62,7 @@ int     SYSTEM_SW_OS(AGENT_REQUEST *request, AGENT_RESULT *result)
 
 	if (NULL == type || '\0' == *type || 0 == strcmp(type, "full"))
 	{
-		if (NULL == (f = fopen(SW_OS_FULL, "r")))
+		if (NULL == (f = zbx_fopen(SW_OS_FULL, "r")))
 		{
 			SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open " SW_OS_FULL ": %s",
 					zbx_strerror(errno)));
@@ -71,7 +71,7 @@ int     SYSTEM_SW_OS(AGENT_REQUEST *request, AGENT_RESULT *result)
 	}
 	else if (0 == strcmp(type, "short"))
 	{
-		if (NULL == (f = fopen(SW_OS_SHORT, "r")))
+		if (NULL == (f = zbx_fopen(SW_OS_SHORT, "r")))
 		{
 			SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open " SW_OS_SHORT ": %s",
 					zbx_strerror(errno)));
@@ -82,7 +82,7 @@ int     SYSTEM_SW_OS(AGENT_REQUEST *request, AGENT_RESULT *result)
 	{
 		/* firstly need to check option PRETTY_NAME in /etc/os-release */
 		/* if cannot find it, get value from /etc/issue.net            */
-		if (NULL != (f = fopen(SW_OS_NAME_RELEASE, "r")))
+		if (NULL != (f = zbx_fopen(SW_OS_NAME_RELEASE, "r")))
 		{
 			while (NULL != fgets(tmp_line, sizeof(tmp_line), f))
 			{
@@ -99,7 +99,7 @@ int     SYSTEM_SW_OS(AGENT_REQUEST *request, AGENT_RESULT *result)
 			zbx_fclose(f);
 		}
 
-		if (FAIL == line_read && NULL == (f = fopen(SW_OS_NAME, "r")))
+		if (FAIL == line_read && NULL == (f = zbx_fopen(SW_OS_NAME, "r")))
 		{
 			SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open " SW_OS_NAME ": %s",
 					zbx_strerror(errno)));
diff --git a/src/libs/zbxsysinfo/linux/swap.c b/src/libs/zbxsysinfo/linux/swap.c
index eaaf0e5..86984e4 100644
--- a/src/libs/zbxsysinfo/linux/swap.c
+++ b/src/libs/zbxsysinfo/linux/swap.c
@@ -130,7 +130,7 @@ static int	get_swap_dev_stat(const char *swapdev, swap_stat_t *result)
 	if (-1 == zbx_stat(swapdev, &dev_st))
 		return ret;
 
-	if (NULL == (f = fopen(INFO_FILE_NAME, "r")))
+	if (NULL == (f = zbx_fopen(INFO_FILE_NAME, "r")))
 		return ret;
 
 	while (NULL != fgets(line, sizeof(line), f))
@@ -143,7 +143,7 @@ static int	get_swap_dev_stat(const char *swapdev, swap_stat_t *result)
 			break;
 		}
 	}
-	fclose(f);
+	zbx_fclose(f);
 
 	return ret;
 }
@@ -158,9 +158,9 @@ static int	get_swap_pages(swap_stat_t *result)
 	FILE	*f;
 
 #ifdef KERNEL_2_4
-	if (NULL != (f = fopen("/proc/stat", "r")))
+	if (NULL != (f = zbx_fopen("/proc/stat", "r")))
 #else
-	if (NULL != (f = fopen("/proc/vmstat", "r")))
+	if (NULL != (f = zbx_fopen("/proc/vmstat", "r")))
 #endif
 	{
 		while (NULL != fgets(line, sizeof(line), f))
@@ -218,12 +218,15 @@ static int	get_swap_stat(const char *swapdev, swap_stat_t *result)
 	else if (0 != strncmp(swapdev, "/dev/", 5))
 		offset = 5;
 
-	if (NULL == (f = fopen("/proc/swaps", "r")))
+	if (NULL == (f = zbx_fopen("/proc/swaps", "r")))
 		return ret;
 
 	while (NULL != fgets(line, sizeof(line), f))
 	{
-		if (0 != strncmp(line, "/dev/", 5))
+		if (0 != strncmp(line, "/", 1))
+			continue;
+
+		if (NULL == strstr(line, "/dev/"))
 			continue;
 
 		if (NULL == (s = strchr(line, ' ')))
@@ -244,7 +247,7 @@ static int	get_swap_stat(const char *swapdev, swap_stat_t *result)
 			ret = SYSINFO_RET_OK;
 		}
 	}
-	fclose(f);
+	zbx_fclose(f);
 
 	return ret;
 }
diff --git a/src/libs/zbxsysinfo/osf/proc.c b/src/libs/zbxsysinfo/osf/proc.c
index 9892d0b..1beea9b 100644
--- a/src/libs/zbxsysinfo/osf/proc.c
+++ b/src/libs/zbxsysinfo/osf/proc.c
@@ -75,20 +75,20 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	if (1 == invalid_user)	/* handle 0 for non-existent user after all parameters have been parsed and validated */
 		goto out;
 
-	if (NULL == (dir = opendir("/proc")))
+	if (NULL == (dir = zbx_opendir("/proc")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		strscpy(filename, "/proc/");
 		zbx_strlcat(filename, entries->d_name, MAX_STRING_LEN);
 
 		if (0 == zbx_stat(filename, &buf))
 		{
-			proc = open(filename, O_RDONLY);
+			proc = zbx_open(filename, O_RDONLY);
 			if (-1 == proc)
 				goto lbl_skip_procces;
 
@@ -128,11 +128,11 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 			}
 lbl_skip_procces:
 			if (-1 != proc)
-				close(proc);
+				zbx_close(proc);
 		}
 	}
 
-	closedir(dir);
+	zbx_closedir(dir);
 
 	if (0 > memsize)
 	{
@@ -199,20 +199,20 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	if (1 == invalid_user)	/* handle 0 for non-existent user after all parameters have been parsed and validated */
 		goto out;
 
-	if (NULL == (dir = opendir("/proc")))
+	if (NULL == (dir = zbx_opendir("/proc")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		strscpy(filename, "/proc/");
 		zbx_strlcat(filename, entries->d_name,MAX_STRING_LEN);
 
 		if (0 == zbx_stat(filename, &buf))
 		{
-			proc = open(filename, O_RDONLY);
+			proc = zbx_open(filename, O_RDONLY);
 			if (-1 == proc)
 				goto lbl_skip_procces;
 
@@ -242,11 +242,11 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 			proccount++;
 lbl_skip_procces:
 			if (-1 != proc)
-				close(proc);
+				zbx_close(proc);
 		}
 	}
 
-	closedir(dir);
+	zbx_closedir(dir);
 out:
 	SET_UI64_RESULT(result, proccount);
 
diff --git a/src/libs/zbxsysinfo/solaris/diskspace.c b/src/libs/zbxsysinfo/solaris/diskspace.c
index 8cba81b..1ccc67d 100644
--- a/src/libs/zbxsysinfo/solaris/diskspace.c
+++ b/src/libs/zbxsysinfo/solaris/diskspace.c
@@ -199,7 +199,7 @@ int	VFS_FS_DISCOVERY(AGENT_REQUEST *request, AGENT_RESULT *result)
 	struct zbx_json	j;
 
 	/* opening the mounted filesystems file */
-	if (NULL == (f = fopen("/etc/mnttab", "r")))
+	if (NULL == (f = zbx_fopen("/etc/mnttab", "r")))
 	{
 		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /etc/mnttab: %s", zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
diff --git a/src/libs/zbxsysinfo/solaris/proc.c b/src/libs/zbxsysinfo/solaris/proc.c
index 1969707..d07a5ea 100644
--- a/src/libs/zbxsysinfo/solaris/proc.c
+++ b/src/libs/zbxsysinfo/solaris/proc.c
@@ -82,6 +82,7 @@ static int	check_procstate(psinfo_t *psinfo, int zbx_proc_stat)
 int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 {
 	char		tmp[MAX_STRING_LEN], *procname, *proccomm, *param, *memtype = NULL;
+	char		path[MAX_STRING_LEN];
 	DIR		*dir;
 	struct dirent	*entries;
 	struct passwd	*usrinfo;
@@ -159,23 +160,25 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	if (1 == invalid_user)	/* handle 0 for non-existent user after all parameters have been parsed and validated */
 		goto out;
 
-	if (NULL == (dir = opendir("/proc")))
+	path = zbx_rootfs_path(path, sizeof(path), "/proc");
+
+	if (NULL == (dir = zbx_opendir(path)))
 	{
-		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc: %s", zbx_strerror(errno)));
+		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open %s: %s", path, zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		if (-1 != fd)
 		{
-			close(fd);
+			zbx_close(fd);
 			fd = -1;
 		}
 
-		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/psinfo", entries->d_name);
+		zbx_snprintf(tmp, sizeof(tmp), "%s/%s/psinfo", path, entries->d_name);
 
-		if (-1 == (fd = open(tmp, O_RDONLY)))
+		if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 			continue;
 
 		if (-1 == read(fd, &psinfo, sizeof(psinfo)))
@@ -227,9 +230,9 @@ int	PROC_MEM(AGENT_REQUEST *request, AGENT_RESULT *result)
 		}
 	}
 
-	closedir(dir);
+	zbx_closedir(dir);
 	if (-1 != fd)
-		close(fd);
+		zbx_close(fd);
 out:
 	if (NULL != p_value)
 	{
@@ -252,6 +255,7 @@ out:
 int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 {
 	char		tmp[MAX_STRING_LEN], *procname, *proccomm, *param;
+	char		path[MAX_STRING_LEN];
 	DIR		*dir;
 	struct dirent	*entries;
 	zbx_stat_t	buf;
@@ -308,26 +312,28 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 	if (1 == invalid_user)	/* handle 0 for non-existent user after all parameters have been parsed and validated */
 		goto out;
 
-	if (NULL == (dir = opendir("/proc")))
+	zbx_rootfs_path(path, sizeof(path), "/proc");
+
+	if (NULL == (dir = zbx_opendir(path)))
 	{
-		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open /proc: %s", zbx_strerror(errno)));
+		SET_MSG_RESULT(result, zbx_dsprintf(NULL, "Cannot open %s: %s", path, zbx_strerror(errno)));
 		return SYSINFO_RET_FAIL;
 	}
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		if (-1 != fd)
 		{
-			close(fd);
+			zbx_close(fd);
 			fd = -1;
 		}
 
-		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/psinfo", entries->d_name);
+		zbx_snprintf(tmp, sizeof(tmp), "%s/%s/psinfo", path, entries->d_name);
 
 		if (0 != zbx_stat(tmp, &buf))
 			continue;
 
-		if (-1 == (fd = open(tmp, O_RDONLY)))
+		if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 			continue;
 
 		if (-1 == read(fd, &psinfo, sizeof(psinfo)))
@@ -348,9 +354,9 @@ int	PROC_NUM(AGENT_REQUEST *request, AGENT_RESULT *result)
 		proccount++;
 	}
 
-	closedir(dir);
+	zbx_closedir(dir);
 	if (-1 != fd)
-		close(fd);
+		zbx_close(fd);
 out:
 	SET_UI64_RESULT(result, proccount);
 
@@ -499,27 +505,30 @@ static int	zbx_solaris_version_get(unsigned int *major_version, unsigned int *mi
  ******************************************************************************/
 static int	proc_read_cpu_util(zbx_procstat_util_t *procutil)
 {
+	char		path[MAX_STRING_LEN];
 	int		fd, n;
 	char		tmp[MAX_STRING_LEN];
 	psinfo_t	psinfo;
 	prusage_t	prusage;
 
-	zbx_snprintf(tmp, sizeof(tmp), "/proc/%d/psinfo", (int)procutil->pid);
+	zbx_rootfs_path(path, sizeof(path), "/proc");
+
+	zbx_snprintf(tmp, sizeof(tmp), "%s/%d/psinfo", path, (int)procutil->pid);
 
-	if (-1 == (fd = open(tmp, O_RDONLY)))
+	if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 		return -errno;
 
 	n = read(fd, &psinfo, sizeof(psinfo));
-	close(fd);
+	zbx_close(fd);
 
 	if (-1 == n)
 		return -errno;
 
 	procutil->starttime = psinfo.pr_start.tv_sec;
 
-	zbx_snprintf(tmp, sizeof(tmp), "/proc/%d/usage", (int)procutil->pid);
+	zbx_snprintf(tmp, sizeof(tmp), "%s/%d/usage", path, (int)procutil->pid);
 
-	if (-1 == (fd = open(tmp, O_RDONLY)))
+	if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 		return -errno;
 
 	n = read(fd, &prusage, sizeof(prusage));
@@ -578,7 +587,7 @@ void	zbx_proc_get_process_stats(zbx_procstat_util_t *procs, int procs_num)
 int	zbx_proc_get_processes(zbx_vector_ptr_t *processes, unsigned int flags)
 {
 	const char		*__function_name = "zbx_proc_get_processes";
-
+	char			path[MAX_STRING_LEN];
 	DIR			*dir;
 	struct dirent		*entries;
 	char			tmp[MAX_STRING_LEN];
@@ -588,22 +597,24 @@ int	zbx_proc_get_processes(zbx_vector_ptr_t *processes, unsigned int flags)
 
 	zabbix_log(LOG_LEVEL_TRACE, "In %s()", __function_name);
 
-	if (NULL == (dir = opendir("/proc")))
+	zbx_rootfs_path(path, sizeof(path), "/proc");
+
+	if (NULL == (dir = zbx_opendir(path)))
 		goto out;
 
-	while (NULL != (entries = readdir(dir)))
+	while (NULL != (entries = zbx_readdir(dir)))
 	{
 		/* skip entries not containing pids */
 		if (FAIL == is_uint32(entries->d_name, &pid))
 			continue;
 
-		zbx_snprintf(tmp, sizeof(tmp), "/proc/%s/psinfo", entries->d_name);
+		zbx_snprintf(tmp, sizeof(tmp), "%s/%s/psinfo", path, entries->d_name);
 
-		if (-1 == (fd = open(tmp, O_RDONLY)))
+		if (-1 == (fd = zbx_open(tmp, O_RDONLY)))
 			continue;
 
 		n = read(fd, &psinfo, sizeof(psinfo));
-		close(fd);
+		zbx_close(fd);
 
 		if (-1 == n)
 			continue;
@@ -629,7 +640,7 @@ int	zbx_proc_get_processes(zbx_vector_ptr_t *processes, unsigned int flags)
 		zbx_vector_ptr_append(processes, proc);
 	}
 
-	closedir(dir);
+	zbx_closedir(dir);
 
 	ret = SUCCEED;
 out:
diff --git a/src/zabbix_agent/cpustat.c b/src/zabbix_agent/cpustat.c
index 0d7cd9d..4f1e54c 100644
--- a/src/zabbix_agent/cpustat.c
+++ b/src/zabbix_agent/cpustat.c
@@ -356,7 +356,7 @@ static void	update_cpustats(ZBX_CPUS_STAT_DATA *pcpus)
 
 #if defined(HAVE_PROC_STAT)
 
-	if (NULL == (file = fopen(filename, "r")))
+	if (NULL == (file = zbx_fopen(filename, "r")))
 	{
 		zbx_error("cannot open [%s]: %s", filename, zbx_strerror(errno));
 		ZBX_SET_CPUS_NOTSUPPORTED();
diff --git a/src/zabbix_agent/logfiles.c b/src/zabbix_agent/logfiles.c
index 8082c7f..f1a565b 100644
--- a/src/zabbix_agent/logfiles.c
+++ b/src/zabbix_agent/logfiles.c
@@ -587,7 +587,7 @@ static int	is_same_file(const struct st_logfile *old, const struct st_logfile *n
 			else
 				ret = ZBX_SAME_FILE_ERROR;
 
-			if (0 != close(f))
+			if (0 != zbx_close(f))
 			{
 				if (ZBX_SAME_FILE_ERROR != ret)
 				{
@@ -1277,7 +1277,7 @@ clean:
 	DIR		*dir = NULL;
 	struct dirent	*d_ent = NULL;
 
-	if (NULL == (dir = opendir(directory)))
+	if (NULL == (dir = zbx_opendir(directory)))
 	{
 		*err_msg = zbx_dsprintf(*err_msg, "Cannot open directory \"%s\" for reading: %s", directory,
 				zbx_strerror(errno));
@@ -1287,12 +1287,12 @@ clean:
 	/* on UNIX file systems we always assume that inodes can be used to identify files */
 	*use_ino = 1;
 
-	while (NULL != (d_ent = readdir(dir)))
+	while (NULL != (d_ent = zbx_readdir(dir)))
 	{
 		pick_logfile(directory, d_ent->d_name, mtime, re, logfiles, logfiles_alloc, logfiles_num);
 	}
 
-	if (-1 == closedir(dir))
+	if (-1 == zbx_closedir(dir))
 	{
 		*err_msg = zbx_dsprintf(*err_msg, "Cannot close directory \"%s\": %s", directory, zbx_strerror(errno));
 		return FAIL;
@@ -1456,7 +1456,7 @@ clean1:
 			ret = FAIL;
 #endif	/*_WINDOWS*/
 clean3:
-		if (0 != close(f))
+		if (0 != zbx_close(f))
 		{
 			*err_msg = zbx_dsprintf(*err_msg, "Cannot close file \"%s\": %s", p->filename,
 					zbx_strerror(errno));
@@ -1938,7 +1938,7 @@ static int	process_log(unsigned char flags, const char *filename, zbx_uint64_t *
 				l_size, filename, zbx_strerror(errno));
 	}
 
-	if (0 != close(f))
+	if (0 != zbx_close(f))
 	{
 		*err_msg = zbx_dsprintf(*err_msg, "Cannot close file \"%s\": %s", filename, zbx_strerror(errno));
 		ret = FAIL;
@@ -2146,7 +2146,7 @@ static int	adjust_position_after_jump(struct st_logfile *logfile, zbx_uint64_t *
 		}
 	}
 out:
-	if (0 != close(fd))
+	if (0 != zbx_close(fd))
 	{
 		*err_msg = zbx_dsprintf(*err_msg, "Cannot close file \"%s\": %s", logfile->filename,
 				zbx_strerror(errno));
diff --git a/src/zabbix_agent/stats.c b/src/zabbix_agent/stats.c
index c644ac0..3d8ef56 100644
--- a/src/zabbix_agent/stats.c
+++ b/src/zabbix_agent/stats.c
@@ -99,10 +99,13 @@ static int	zbx_get_cpu_num()
 
 	return ncpu;
 #elif defined(HAVE_PROC_CPUINFO)
+	char	path[MAX_STRING_LEN];
 	FILE	*f = NULL;
 	int	ncpu = 0;
 
-	if (NULL == (file = fopen("/proc/cpuinfo", "r")))
+	zbx_rootfs_path(path, sizeof(path), "/proc/cpuinfo");
+
+	if (NULL == (file = zbx_fopen(path, "r")))
 		goto return_one;
 
 	while (NULL != fgets(line, 1024, file))
diff --git a/src/zabbix_agent/zabbix_agentd.c b/src/zabbix_agent/zabbix_agentd.c
index 405d643..1b2cb79 100644
--- a/src/zabbix_agent/zabbix_agentd.c
+++ b/src/zabbix_agent/zabbix_agentd.c
@@ -747,6 +747,8 @@ static void	zbx_load_config(int requirement, ZBX_TASK_EX *task)
 			PARM_OPT,	0,			1},
 		{"User",			&CONFIG_USER,				TYPE_STRING,
 			PARM_OPT,	0,			0},
+		{"RootFilesystem",		&CONFIG_ROOT_FILESYSTEM,		TYPE_STRING,
+			PARM_OPT,	0,			0},
 #endif
 #ifdef _WINDOWS
 		{"PerfCounter",			&CONFIG_PERF_COUNTERS,			TYPE_MULTISTRING,
diff --git a/src/zabbix_agent/zbxconf.c b/src/zabbix_agent/zbxconf.c
index 0fc906d..5ebdddc 100644
--- a/src/zabbix_agent/zbxconf.c
+++ b/src/zabbix_agent/zbxconf.c
@@ -59,6 +59,7 @@ char	**CONFIG_PERF_COUNTERS		= NULL;
 #endif
 
 char	*CONFIG_USER			= NULL;
+char	*CONFIG_ROOT_FILESYSTEM	= NULL;
 
 /* TLS parameters */
 unsigned int	configured_tls_connect_mode = ZBX_TCP_SEC_UNENCRYPTED;
diff --git a/src/zabbix_agent/zbxconf.h b/src/zabbix_agent/zbxconf.h
index 04a2c4b..5e7ded8 100644
--- a/src/zabbix_agent/zbxconf.h
+++ b/src/zabbix_agent/zbxconf.h
@@ -40,6 +40,9 @@ extern char	**CONFIG_LOAD_MODULE;
 extern char	**CONFIG_PERF_COUNTERS;
 #endif
 extern char	*CONFIG_USER;
+#ifndef _WINDOWS
+extern char	*CONFIG_ROOT_FILESYSTEM;
+#endif
 
 extern unsigned int	configured_tls_connect_mode;
 extern unsigned int	configured_tls_accept_modes;
diff --git a/src/zabbix_server/snmptrapper/snmptrapper.c b/src/zabbix_server/snmptrapper/snmptrapper.c
index 2f96277..6d99970 100644
--- a/src/zabbix_server/snmptrapper/snmptrapper.c
+++ b/src/zabbix_server/snmptrapper/snmptrapper.c
@@ -500,7 +500,35 @@ static int	open_trap_file()
 	zbx_stat_t	file_buf;
 	char		*error = NULL;
 
-	if (0 != zbx_stat(CONFIG_SNMPTRAP_FILE, &file_buf))
+#ifdef _WINDOWS
+	int	stat, fd;
+	wchar_t	*wpath;
+
+	wpath = zbx_utf8_to_unicode(CONFIG_SNMPTRAP_FILE);
+
+	if (-1 == (stat = _wstat64(wpath, &file_buf)))
+		goto out;
+
+	if (0 != S_ISDIR(file_buf->st_mode) || 0 != file_buf->st_size)
+		goto out;
+
+	/* In the case of symlinks _wstat64 returns zero file size.   */
+	/* Try to work around it by opening the file and using fstat. */
+
+	stat = -1;
+
+	if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+	{
+		stat = _fstat64(fd, &file_buf);
+		_close(fd);
+	}
+out:
+	zbx_free(wpath);
+
+	if (0 != stat)
+#else
+	if (0 != stat(CONFIG_SNMPTRAP_FILE, &file_buf))
+#endif
 	{
 		error = zbx_dsprintf(error, "cannot stat SNMP trapper file \"%s\": %s", CONFIG_SNMPTRAP_FILE,
 				zbx_strerror(errno));
@@ -553,7 +581,35 @@ static int	get_latest_data()
 
 	if (-1 != trap_fd)	/* a trap file is already open */
 	{
-		if (0 != zbx_stat(CONFIG_SNMPTRAP_FILE, &file_buf))
+#ifdef _WINDOWS
+		int	stat, fd;
+		wchar_t	*wpath;
+
+		wpath = zbx_utf8_to_unicode(CONFIG_SNMPTRAP_FILE);
+
+		if (-1 == (stat = _wstat64(wpath, &file_buf)))
+			goto out;
+
+		if (0 != S_ISDIR(file_buf->st_mode) || 0 != file_buf->st_size)
+			goto out;
+
+		/* In the case of symlinks _wstat64 returns zero file size.   */
+		/* Try to work around it by opening the file and using fstat. */
+
+		stat = -1;
+
+		if (-1 != (fd = _wopen(wpath, O_RDONLY)))
+		{
+			stat = _fstat64(fd, &file_buf);
+			_close(fd);
+		}
+out:
+		zbx_free(wpath);
+
+		if (0 != stat)
+#else
+		if (0 != stat(CONFIG_SNMPTRAP_FILE, &file_buf))
+#endif
 		{
 			/* file might have been renamed or deleted, process the current file */
 
@@ -669,5 +725,5 @@ ZBX_THREAD_ENTRY(snmptrapper_thread, args)
 	zbx_free(buffer);
 
 	if (-1 != trap_fd)
-		close(trap_fd);
+		zbx_close(trap_fd);
 }
-- 
2.9.3

